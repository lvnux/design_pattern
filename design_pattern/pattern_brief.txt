|------------------------------------------------------------------------|
|        |            |                     目的                         |
|--------|------------|--------------|----------------|------------------|
|        |            | 创建型模式    |   结构型模式    |   行为型模式     |
|--------|------------|--------------|----------------|------------------|
|        |   类模式    | 工厂方法模式  |   适配器模式    |   解释器模式     |
|        |            |              |                |   模板方法模式   |
|        |------------|--------------|----------------|------------------|
|        |            | 抽象工厂模式  |   适配器模式    |   职责链模式     |
|        |            | 生成器模式    |   桥接模式      |   命令模式       |
|范 围   |            | 原型模式      |   复合模式      |   迭代器模式     |
|        |            | 单件模式      |   装饰模式      |   中介者模式     |
|        |  对象模式   |              |   外观模式      |   备忘录模式     |
|        |            |              |   享元模式      |   观察者模式     |
|        |            |              |   代理模式      |   状态模式       |
|        |            |              |                |   策略模式       |
|        |            |              |                |   访问者模式     |
|------------------------------------------------------------------------|


抽象工厂模式（Abstract Factory）， 意图：动态地选择创建多组产品对象中的某一组。添加新的产品对象组非常容易。
                                实现要点：定义一个抽象工厂的接口类，由该接口的派生类具体决定创建哪一组产品。
                                
生成器模式（Builder）， 意图：动态地组合创建一个复杂对象的多个步骤，每一个步骤也可以很容易地发生变化。
                        实现要点：定义一个抽象生成器的接口类，由该接口的派生类具体决定创建过程的每一个步骤如何实现。
                        
工厂方法模式（Factory Method）， 意图：对new操作的进一步封装，用户不用提供类名就能创建对象，能动态改变创建出的对象类型。
                                 实现要点：定义工厂方法（虚函数），推迟到派生类再实现该方法。
                                 
原型模式（Prototype）， 意图：通过拷贝原型对象来创建新的对象，改变原型对象就能动态地改变产品对象的类型。
                        实现要点：定义克隆方法（虚函数），在所有的产品对象中实现这个克隆方法。
                        
单件模式（Singleton）， 意图：实现只有唯一对象实例的类（和适应变化无关）。
                        实现要点：用静态数据成员和函数实现。
                        
适配器模式（Adapter）， 意图：把一个接口转换成另外一个接口，隔离两个子系统，使它们的变化不会互相影响。
                        实现要点：定义一个目的接口，可以通过继承或聚合被适配类来实现。
                        
桥接模式（Bridge）， 意图：分离类的接口和实现，在接口不变的情况下，可以动态地改变类的实现。
                     实现要点：分别定义抽象的接口和实现的接口，抽象的接口类中聚合一个实现的接口的引用，该引用就是连接接口和实现的桥梁。
                     
复合模式（Composite）， 意图：定义整体和部分对象的继承和聚合结构。很容易添加新的整体或部分的对象。
                        实现要点：整体和部分类继承与同一个接口，整体接口聚合部分接口。
                        
装饰模式（Decorator）， 意图：通过聚合而不是继承的方式扩充一个类的功能。可以动态选择功能。
                        实现要点：实现结构类似于复合模式，但目的是扩充类的功能。
                        
外观模式（Facade）， 意图：为子系统提供一个统一的接口，子系统的变化不会影响系统的其他部分。
                     实现要点：接口类负责把请求转发给子系统中的其他对象。
                     
享元模式（Flyweight）， 意图：共享小对象，解决面向对象设计中对象过多的问题。
                        实现要点：享元工厂通过享元接口管理（聚合）所有的享元对象，客户类必须通过享元工厂访问享元对象。
                        
代理模式（Proxy）， 意图：通过代理访问另外一个对象，被代理对象的位置、实现以及变化不会对客户类产生影响。
                    实现要点：代理类和被代理类继承于同一个接口，代理类通过引用聚合被代理类。
                    
职责链模式（Chian Of Responsibility）， 意图：把请求发送给一条职责链，职责链上的多个对象都有机会处理请求，对象自己决定如何处理该请求。
                                              很容易添加、删除或改变职责链上的处理环节。
                                        实现要点：定义请求处理接口，派生类可以自己决定如何处理请求，具体的请求处理对象被组织成了一条职责链。
                                        
命令模式（Command）， 意图：把请求封装成命令对象，发送者、命令和接收者对象三者之间松散耦合，都可以很容易地发生变化，很容易地实现宏命令、
                            命令的撤销等操作。
                      实现要点：定义命令接口，具体的命令类可以决定如何处理请求，既可以自己处理，也可以把该请求发送给另一个接收者处理。
                      
解释器模式（Interpreter）， 意图：处理类似语言语法的结构，很容易添加新的语法，以及改变原有语法的组织形式。
                            实现要点；定义语法表达式接口类，具体的语法表达式的组织结构类似复合模式。
                            
迭代器模式（Iterator）， 意图：遍历聚合对象中的元素，不用关心这些元素的实现。容器、迭代器和算法之间相互独立，很容易定义新的迭代器和算法。
                         实现要点：定义容器和迭代器接口类，具体的迭代器实现访问容器的方法。
                         
中介者模式（Mediator）， 意图：用中介者隔离发送者和接收者，发送者和接收者之间没有耦合，可以独立地发生变化。
                         实现要点；定义中介者和协作者接口类，中介者管理所有的协作者之间的关联关系。
                         
备忘录模式（Memento）， 意图：客户类可以存储服务器类的状态，而不用知道服务器类的内部结构，服务器类的变化不影响客户类。
                        实现要点：定义一个备忘录类来保存服务器类的状态，备忘录类隔离了客户类和服务器类。
                        
观察者模式（Observe）， 意图：一对多的事件传输结构，发送者不直接依赖于接收者，接收者的变化不会影响发送者。
                        实现要点：定义观察者和主体接口类，具体的观察者通过注册机制，在具体的主体类中进行注册。
                        
状态模式（State）， 意图：对象状态发生变化时，动态地改变行为，很容易添加新的状态。
                    实现要点：定义状态接口类，具体的状态类中实现该状态对应的行为，上下文对象中聚合一个当前使用的状态。
                    
策略模式（Strategy）， 意图：封装一系列算法，可以动态选择使用哪一个算法，很容易添加新的算法。
                       实现要点：定义策略接口类，具体的策略类中实现具体的算法，上下文对象中聚合一个当前使用的策略。
                       
模板方法模式（Template Method）， 意图：不改变算法的结构就能重新定义算法中的某些步骤。
                                  实现要点：抽象类中实现算法的骨架，派生类中实现算法的具体步骤。
                                  
访问者模式（Visitor）， 意图：分离一个类结构和定义在这个类结构之上的操作，可以在不改变类结构的前提下添加新的操作。
                        实现要点：定义访问者接口，具体的访问者类实现具体的操作。
