# design_pattern
学习设计模式

设计模式六大原则：
1、单一职责原则（Single Responsibility Principle）
	不要存在多于一个导致类变更的原因。通俗地说，即一个类只负责一项职责。

2、里氏替换原则（Liskov Substitution Principle）
	所有引用基类的地方必须能透明地使用其子类的对象。
	通俗地将就是：子类可以扩展父类的功能，但不能改变父类原有的功能。包含4层含义：
	<ol>
		<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
		<li>子类中可以增加自己特有的方法。</li>
		<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类的方法输入参数更宽松。</li>
		<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li>
	</ol>

3、依赖倒置原则（Dependence Inversion Principle）
	高层模块不应该依赖底层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。
	依赖倒置原则的中心思想：面向接口编程。

4、接口隔离原则（Interface Segregation Principle）
	客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。

5、迪米特法则（Law Of Demeter）
	一个对象应该对其他对象保持最少的了解。
	只与直接的朋友通信。（出现在成员变量、方法参数、方法返回值中的类为直接的朋友）

6、开闭原则（Open Close Principle）
	一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。


设计模式简述：

|      范围\目的      | 创建型模式  | 结构型模式 |  行为型模式 |
|------------|--------------|----------------|------------------|
|   类模式    | 工厂方法模式  |   适配器模式    |   解释器模式     |
|            |              |                |   模板方法模式   |
|            | 抽象工厂模式  |   适配器模式    |   职责链模式     |
|            | 生成器模式    |   桥接模式      |   命令模式       |
|            | 原型模式      |   复合模式      |   迭代器模式     |
|            | 单件模式      |   装饰模式      |   中介者模式     |
|  对象模式   |              |   外观模式      |   备忘录模式     |
|            |              |   享元模式      |   观察者模式     |
|            |              |   代理模式      |   状态模式       |
|            |              |                |   策略模式       |
|            |              |                |   访问者模式     |


抽象工厂模式（Abstract Factory）， 意图：动态地选择创建多组产品对象中的某一组。添加新的产品对象组非常容易。
                                实现要点：定义一个抽象工厂的接口类，由该接口的派生类具体决定创建哪一组产品。
                                
生成器模式（Builder）， 意图：动态地组合创建一个复杂对象的多个步骤，每一个步骤也可以很容易地发生变化。
                        实现要点：定义一个抽象生成器的接口类，由该接口的派生类具体决定创建过程的每一个步骤如何实现。
                        
工厂方法模式（Factory Method）， 意图：对new操作的进一步封装，用户不用提供类名就能创建对象，能动态改变创建出的对象类型。
                                 实现要点：定义工厂方法（虚函数），推迟到派生类再实现该方法。
                                 
原型模式（Prototype）， 意图：通过拷贝原型对象来创建新的对象，改变原型对象就能动态地改变产品对象的类型。
                        实现要点：定义克隆方法（虚函数），在所有的产品对象中实现这个克隆方法。
                        
单件模式（Singleton）， 意图：实现只有唯一对象实例的类（和适应变化无关）。
                        实现要点：用静态数据成员和函数实现。
                        
适配器模式（Adapter）， 意图：把一个接口转换成另外一个接口，隔离两个子系统，使它们的变化不会互相影响。
                        实现要点：定义一个目的接口，可以通过继承或聚合被适配类来实现。
                        
桥接模式（Bridge）， 意图：分离类的接口和实现，在接口不变的情况下，可以动态地改变类的实现。
                     实现要点：分别定义抽象的接口和实现的接口，抽象的接口类中聚合一个实现的接口的引用，该引用就是连接接口和实现的桥梁。
                     
复合模式（Composite）， 意图：定义整体和部分对象的继承和聚合结构。很容易添加新的整体或部分的对象。
                        实现要点：整体和部分类继承与同一个接口，整体接口聚合部分接口。
                        
装饰模式（Decorator）， 意图：通过聚合而不是继承的方式扩充一个类的功能。可以动态选择功能。
                        实现要点：实现结构类似于复合模式，但目的是扩充类的功能。
                        
外观模式（Facade）， 意图：为子系统提供一个统一的接口，子系统的变化不会影响系统的其他部分。
                     实现要点：接口类负责把请求转发给子系统中的其他对象。
                     
享元模式（Flyweight）， 意图：共享小对象，解决面向对象设计中对象过多的问题。
                        实现要点：享元工厂通过享元接口管理（聚合）所有的享元对象，客户类必须通过享元工厂访问享元对象。
                        
代理模式（Proxy）， 意图：通过代理访问另外一个对象，被代理对象的位置、实现以及变化不会对客户类产生影响。
                    实现要点：代理类和被代理类继承于同一个接口，代理类通过引用聚合被代理类。
                    
职责链模式（Chian Of Responsibility）， 意图：把请求发送给一条职责链，职责链上的多个对象都有机会处理请求，对象自己决定如何处理该请求。
                                              很容易添加、删除或改变职责链上的处理环节。
                                        实现要点：定义请求处理接口，派生类可以自己决定如何处理请求，具体的请求处理对象被组织成了一条职责链。
                                        
命令模式（Command）， 意图：把请求封装成命令对象，发送者、命令和接收者对象三者之间松散耦合，都可以很容易地发生变化，很容易地实现宏命令、
                            命令的撤销等操作。
                      实现要点：定义命令接口，具体的命令类可以决定如何处理请求，既可以自己处理，也可以把该请求发送给另一个接收者处理。
                      
解释器模式（Interpreter）， 意图：处理类似语言语法的结构，很容易添加新的语法，以及改变原有语法的组织形式。
                            实现要点；定义语法表达式接口类，具体的语法表达式的组织结构类似复合模式。
                            
迭代器模式（Iterator）， 意图：遍历聚合对象中的元素，不用关心这些元素的实现。容器、迭代器和算法之间相互独立，很容易定义新的迭代器和算法。
                         实现要点：定义容器和迭代器接口类，具体的迭代器实现访问容器的方法。
                         
中介者模式（Mediator）， 意图：用中介者隔离发送者和接收者，发送者和接收者之间没有耦合，可以独立地发生变化。
                         实现要点；定义中介者和协作者接口类，中介者管理所有的协作者之间的关联关系。
                         
备忘录模式（Memento）， 意图：客户类可以存储服务器类的状态，而不用知道服务器类的内部结构，服务器类的变化不影响客户类。
                        实现要点：定义一个备忘录类来保存服务器类的状态，备忘录类隔离了客户类和服务器类。
                        
观察者模式（Observe）， 意图：一对多的事件传输结构，发送者不直接依赖于接收者，接收者的变化不会影响发送者。
                        实现要点：定义观察者和主体接口类，具体的观察者通过注册机制，在具体的主体类中进行注册。
                        
状态模式（State）， 意图：对象状态发生变化时，动态地改变行为，很容易添加新的状态。
                    实现要点：定义状态接口类，具体的状态类中实现该状态对应的行为，上下文对象中聚合一个当前使用的状态。
                    
策略模式（Strategy）， 意图：封装一系列算法，可以动态选择使用哪一个算法，很容易添加新的算法。
                       实现要点：定义策略接口类，具体的策略类中实现具体的算法，上下文对象中聚合一个当前使用的策略。
                       
模板方法模式（Template Method）， 意图：不改变算法的结构就能重新定义算法中的某些步骤。
                                  实现要点：抽象类中实现算法的骨架，派生类中实现算法的具体步骤。
                                  
访问者模式（Visitor）， 意图：分离一个类结构和定义在这个类结构之上的操作，可以在不改变类结构的前提下添加新的操作。
                        实现要点：定义访问者接口，具体的访问者类实现具体的操作。

